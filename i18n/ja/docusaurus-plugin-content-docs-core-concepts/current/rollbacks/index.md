# ロールバック処理

ロールバックは、カルダノチェーンの動作に不可欠な要素です。Cardanoの上に構築され、その動作をチェーンと同期させるアプリケーションは、時折そのようなロールバックを観察する覚悟が必要であり、Hydraもその例外ではありません。

この短い文書では、ロールバックとは何か、ロールバックはどこから発生するのか、そしてHydra headがそれらをどのように処理するのかについて説明します。

## ロールバックとは？

ロールバックは、Cardanoチェーンまたはその他の真に分散化されたブロックチェーンで発生します。これは、本質的に非同期であるためです。各ノードには、他のノードと通信したり既知のブロックに関するメッセージを交換したりすることで更新されるチェーンの状態に関する独自のビューがあり、このプロセスには時間がかかります。新しいブロックが生成された場合、これは有効または無効であるかもしれません。そしてチェーンの状態は最終的な整合性があり、すべてのノードはいくつかのブロックが処理された後にのみチェーンの状態に同意します。

実際にはロールバックは誤った名称であり、フォークについて話す必要があります。Hydra Headを実行している3つのノードの視点からこれが何を意味するかを見てみましょう。次の図は、レイヤー1チェーンの各ノードのビューを表しています。

![](rollbacks-1.jpg)

**_immutable part_** は、現在の _tip_ から過去に`k`ブロック（メインネットでは`k`は2160）であり、すべてのノードで同一であることが保証されています。ここで、ノード2はノード1と同じ新しいブロックを受け取りますが、ノード3は異なるブロックを受け取ります。最終的にノード3のチェーンは他のチェーンより短いので、より長いチェーンに取って代わられ、_ロールバック_ されることになります。

次の図では、ノードのダイレクトチェーンオブザーバーで何が起こるかを詳しく説明します。

![](rollbacks-2.jpg)

新しいブロックが利用可能になると、`ChainSync` クライアントは新しいブロックごとに `RollForward` メッセージを受信します。これはチェーンがロールバックされたスロットとブロックハッシュを特定するものです (図では一つの数字として抽象化されています)。そして `RollForward` メッセージを通して新しいブロックの受信を再開します。

## どのようにHydraノードに影響しますか？

トランザクションがチェーン上で観察されると、最初に初期化してからコミットを収集し、 CollectComトランザクションを通じてヘッドを開き、最終的にそれを閉じてヘッドの最後のUTxOをファンアウトすることにより、ヘッドの状態を変更する可能性があるため、ロールバックには問題があります。

次の図は、潜在的に競合する`Commit`トランザクションにつながるロールバックの問題を示しています。

![](rollbacks-3.jpg)

ヘッドがロールバックを適切に処理しない場合、ヘッドに参加している他のノードとの間で矛盾した状態になる危険があります。したがって、ダイレクトチェーンコンポーネントのレベルで観察されたロールバックは、HeadLogicがその状態をリセットしてレイヤー1で起こったものと一致させるために、HeadLogicに伝搬されることが重要である。

ヘッドの状態に対するロールバックの結果は、ヘッドがどの時点でロールバックされるかに応じて異なります。
1. ヘッドが開いている前または後にロールバックが発生した場合。例えば `CollectCom` トランザクションの前か `Close` トランザクションの後なら、状況は比較的簡単です。ロールバックされたトランザクションが監視される前の時点にヘッドの状態をリセットできます。
2. ヘッドが開いているときに発生した場合。例えば `CollectCom` トランザクションがロールバックされた場合、ノードは既にピアとのメッセージ交換を開始しており、その状態はもはやチェーンだけに依存しているため、ヘッドが開いている間にそれが起こると、より大きな問題になります。

## どのように扱いますか？

:::warning

🛠 Hydra は現在、例えば上記のケース1のような単純なケースではロールバックを適切に処理しますが、CollectCom が起こったときに賢いことをしようとしないため、ヘッドが簡単に古くなってしまう可能性があります。あるノードが他のノードから非同期になっているため(Collectcom トランザクションのロールバックを観察し、その前に状態をリセットしたため、ヘッドが開いていた間に起こったすべてのことを見失い)、ヘッドを閉じる必要があります。
:::

次のシーケンス図に示すように、ロールバックはヘッドで非常に簡単な方法で処理されます。

![](rollbacks-4.jpg)

* 関連するトランザクションが観測されると、例えば上図のケースでは `OnInit` や `OnCommit` が発生し、以前の状態にリンクされた新しい `HeadState` を生成します。
* ロールバックが発生すると、 `HeadLogic` に `Rollback` イベントが通知され、ロールバックが必要なステップ数が伝えられます。`HeadLogic` レイヤーは `Point Block` がオンチェーンで詳細を気にする必要はなく、以前の状態に簡単に「ロールバック」できる一連の状態を保存するだけです。